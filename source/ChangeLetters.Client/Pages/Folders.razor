@page "/folders"
@using Blazored.Modal
@using Blazored.Modal.Services
@using ChangeLetters.DTOs
@using ChangeLetters.Client.Connectors
@using ChangeLetters.Client.Components
@using ChangeLetters.Client.Components.Grids
@using ChangeLetters.Client.Components.Buttons
@rendermode @(new InteractiveWebAssemblyRenderMode(false))

@implements IDisposable

<PageTitle>Select folder</PageTitle>
<div class="mb-2">
    @_currentFolder
</div>
@if (_folderSelected && !_unknownEntries.Any())
{
    @if (_currentFolder != Root)
    {
        <div class="mb-2">
            <ButtonUp CurrentFolder="_currentFolder" ButtonUpClicked="() => OpenFolderAsync(GetParent())" />
        </div>
    }
    <div class="mb-2">
        <button class="btn-secondary" @onclick="SelectFoldersAgainAsync">Select another folder</button>
    </div>
}
@if (!_folderSelected)
{
    @if (_folders is null)
    {
        <div class="spinner-border" role="status">
            <span class="visually-hidden">Loading folders...</span>
        </div>
    }
    else if (_folders.Length == 0)
    {
        <p>No folders found.</p>
        <ButtonUp CurrentFolder="_currentFolder" ButtonUpClicked="() => OpenFolderAsync(GetParent())" />
    }
    else
    {
        <div class="modal show d-block" tabindex="-1">
            <div class="modal-dialog modal-lg">
                <div class="modal-content thick-border modal-back-color">
                    <div class="modal-header">
                        <h5 class="modal-title">Select folder</h5>
                    </div>
                    <div class="modal-body">
                        <ButtonUp CurrentFolder="_currentFolder" ButtonUpClicked="() => OpenFolderAsync(GetParent())" />
                        <ButtonCancel Clicked="CancelFolderSelection" />
                        <SelectFoldersGrid Items="CurrentFolders"
                                           OpenFolderClicked="s => OpenFolderAsync(s)"
                                           ReadUnknownWordsClicked="s => ReadUnknownWordsAsync(s)" />
                    </div>
                    @if (_currentlyReadFolder != string.Empty)
                    {
                        <div class="modal-footer">
                            <ReadingFolderProgress ProgressValue="@_progressValue"
                                                   ProgressMax="@_progressMax"
                                                   CurrentlyReadFolder="@_currentlyReadFolder" />
                        </div>
                    }
                </div>
            </div>
        </div>
    }
}
@if (_unknownEntries.Any())
{
    if (_unknownEntries.Any(x => !x.Value.IsCorrected()))
    {
        <UnknownWordsGrid NewEntries="_unknownEntries" SubmitClicked="SaveVocabulary" AllowEdit="false" />
    }
    else
    {
        <div class="mb-2">
            <button class="btn-success" @onclick="RenameItems" disabled="@_isRenaming">Rename items</button>
            <button class="btn-secondary" @onclick="DoFolderSelection">Select another folder</button>
        </div>
        @if (_isRenaming)
        {
            @if (!_foldersRenamed)
            {
                <div class="mb-2">renaming folders...</div>
            }
            else
            {
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="RenameFolders" @bind="_foldersRenamed" disabled>
                    <label class="form-check-label" for="RenameFolders">folders renamed</label>
                </div>
                @if (!_filesRenamed)
                {
                    <div class="mb-2">renaming files...</div>
                }
                else
                {
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="RenameFiles" @bind="_filesRenamed" disabled>
                        <label class="form-check-label" for="RenameFiles">files renamed</label>
                    </div>
                }
            }
            <RenameItemsProgressBar ChangeValue="@_changeValue" ChangeMax="@_changeMax" />
            <InfoDialog Title="Finished renaming operation"
                           Message="@_dialogMessage"
                           IsVisible="@_showDialog"
                           OnOk="OnDialogOk" />
        }
    }
}

@code {
    private const string Root = "/";
    private int _changeMax = 1;
    private int _progressMax = 1;
    private int _changeValue = 0;
    private int _progressValue = 0;
    private bool _isRenaming = false;
    private string _currentFolder = Root;
    private FileItem[]? _folders = null!;
    private bool _folderSelected = false;
    private bool _showDialog = false;
    private string _dialogMessage = string.Empty;
    private bool _foldersRenamed, _filesRenamed;
    private string _currentlyReadFolder = string.Empty;
    private CancellationTokenSource _cancellationTokenSource = new();
    private Dictionary<string, VocabularyEntry> _unknownEntries = new();

    [Inject] public IJSRuntime? Js { get; set; }
    [Inject] public IFtpConnectorClient? FtpConnector { get; set; }
    [Inject] public IVocabularyConnector? VocabularyConnector { get; set; }
    [Inject] public ISignalRRenameConnector? SignalRRenameConnector { get; set; }
    [Inject] public IModalService? ModalService { get; set; }
    protected override Task OnInitializedAsync()
        => OpenFolderAsync(_currentFolder);

    private IQueryable<FileItem> CurrentFolders
        => _folders?.AsQueryable() ?? new EnumerableQuery<FileItem>([]);

    private async Task OpenFolderAsync(string fullName)
    {
        if (FtpConnector != null)
        {
            var localCts = await RecreateCancellationTokenSource();
            var token = localCts.Token;

            _folders = await FtpConnector.ReadFoldersAsync(fullName, token);
            _currentFolder = fullName;
            StateHasChanged();
            if (!localCts.IsCancellationRequested)
                await CheckQuestionMarksAsync(localCts);
        }
    }

    private async Task CheckQuestionMarksAsync(CancellationTokenSource localCts)
    {
        var folders = _folders;
        var token = localCts.Token;
        if (folders != null && FtpConnector != null)
        {
            if (_cancellationTokenSource != localCts)
                return;

            _progressValue = 0;
            _progressMax = folders.Length;
            Console.WriteLine($"read {folders.Length} items");
            foreach (var fileItem in folders)
            {
                if (token.IsCancellationRequested || _cancellationTokenSource != localCts)
                {
                    if (_cancellationTokenSource == localCts)
                        SetReadingFinished();
                    return;
                }
                _currentlyReadFolder = fileItem.Name;
                StateHasChanged();
                if (fileItem.FolderStatus == FolderStatus.Undefined)
                {
                    await FtpConnector.CheckQuestionMarksAsync(fileItem, token);
                    _progressValue++;
                    if (fileItem.FolderStatus != FolderStatus.Undefined)
                        StateHasChanged();
                }

                await Task.Yield();
            }
            if (_cancellationTokenSource == localCts)
                SetReadingFinished();
        }
    }

    private void SetReadingFinished()
    {
        _progressMax = 1;
        _progressValue = 0;
        _currentlyReadFolder = string.Empty;
        StateHasChanged();
    }

    private async Task ReadUnknownWordsAsync(string fullName)
    {
        _unknownEntries.Clear();
        var localCts = await RecreateCancellationTokenSource();
        var token = localCts.Token;
        SetReadingFinished();
        if (FtpConnector != null)
        {
            _currentFolder = fullName;
            _unknownEntries = await FtpConnector.ReadUnknownWordsAsync(fullName, token);
            _folderSelected = true;
            StateHasChanged();
        }
    }

    private void SaveVocabulary()
    {
        VocabularyConnector?.UpsertEntriesAsync(_unknownEntries.Values);
        _unknownEntries.Clear();
    }

    private async Task RenameItems()
    {
        if (FtpConnector != null && VocabularyConnector != null && Js != null && SignalRRenameConnector != null)
        {
            var localCts = await RecreateCancellationTokenSource();
            _isRenaming = true;
            var token = localCts.Token;
            var connectionId = await ConnectRenamingEventsAsync(token);
            var request = new RenameFileItemsRequest { Folder = _currentFolder, FileItemType = FileItemType.Folder, SignalRConnectionId = connectionId };
            var result = await FtpConnector.RenameItemsAsync(request, token);
            if (!result.Succeeded)
            {
                await CleanUpFailedRenameOperation(token, result);
                return;
            }
            _foldersRenamed = true;
            StateHasChanged();
            request.FileItemType = FileItemType.File;
            result = await FtpConnector.RenameItemsAsync(request, token);
            if (!result.Succeeded)
            {
                await CleanUpFailedRenameOperation(token, result);
                return;
            }
            _filesRenamed = true;
            DoFolderSelection();
            SetCurrentFolderToOk();
            _showDialog = true;
            _dialogMessage = $"Renamed {_changeValue} items in {_currentFolder}";
            StateHasChanged();
            SetRenamingFinished();
            StateHasChanged();
        }
    }
    private void OnDialogOk()
    {
        _showDialog = false;
        StateHasChanged();
    }

    private async Task CleanUpFailedRenameOperation(CancellationToken token, RenameFileItemsResult result)
    {
        if (!token.IsCancellationRequested)
            await Js!.InvokeVoidAsync("alert", token, $"Could not rename {result.FailedFile}");
        SetRenamingFinished();
    }

    private async Task<string> ConnectRenamingEventsAsync(CancellationToken token)
    {
        var connectionId = await SignalRRenameConnector!.ConnectAsync(token);
        SignalRRenameConnector.CurrentItemCountChanged += SignalROnCurrentItemCountChanged;
        SignalRRenameConnector.CompleteItemCountChanged += SignalROnCompleteItemCountChanged;
        return connectionId;
    }

    private void SignalROnCurrentItemCountChanged(CurrentItemCount currentItemCount)
    {
        _changeValue = currentItemCount.Current;
        StateHasChanged();
    }

    private void SignalROnCompleteItemCountChanged(CompleteItemCount completeItemCount)
    {
        SetChangeMax(completeItemCount.Total);
        StateHasChanged();
    }

    private void SetRenamingFinished()
    {
        SignalRRenameConnector!.CurrentItemCountChanged -= SignalROnCurrentItemCountChanged;
        SignalRRenameConnector.CompleteItemCountChanged -= SignalROnCompleteItemCountChanged;
        SetChangeMax(1);
        _changeValue = 0;
        _isRenaming = false;
        _filesRenamed = false;
        _foldersRenamed = false;
    }

    private void SetChangeMax(int max)
    {
        _changeMax = max;
        if (_changeMax < 1)
            _changeMax = 1;
    }

    private async Task SelectFoldersAgainAsync()
    {
        _unknownEntries.Clear();
        _folderSelected = false;
        StateHasChanged();
        await OpenFolderAsync(_currentFolder);
    }

    private void SetCurrentFolderToOk()
    {
        var item = _folders?.FirstOrDefault(f => f.FullName == _currentFolder);
        if (item != null)
            item.FolderStatus = FolderStatus.Ok;
    }

    private string GetParent()
        => Path.GetDirectoryName(_currentFolder)?.Replace("\\", "/") ?? "/";

    public void Dispose()
    {
        _cancellationTokenSource.Cancel();
        _cancellationTokenSource.Dispose();
        SignalRRenameConnector?.DisposeAsync().AsTask().Wait();
    }

    private void DoFolderSelection()
    {
        _folderSelected = false;
        _unknownEntries.Clear();
    }

    private void CancelFolderSelection()
    {
        _folders = [];
        _cancellationTokenSource.Cancel();
    }

    private async Task<CancellationTokenSource> RecreateCancellationTokenSource()
    {
        var localCts = new CancellationTokenSource();
        await _cancellationTokenSource.CancelAsync();
        _cancellationTokenSource.Dispose();
        _cancellationTokenSource = localCts;
        return localCts;
    }

}