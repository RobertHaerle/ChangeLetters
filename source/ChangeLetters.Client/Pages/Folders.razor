@page "/folders"
@using ChangeLetters.Client.Connectors
@using ChangeLetters.Client.SharedComponents.Grids
@using ChangeLetters.Client.SharedComponents.Buttons
@using ChangeLetters.Client.SharedComponents.Dialogs
@using ChangeLetters.Client.SharedComponents.ProgressBars
@using ChangeLetters.Shared
@rendermode @(new InteractiveWebAssemblyRenderMode(false))

@implements IDisposable

@inject IJSRuntime Js
@inject IFtpConnectorClient FtpConnector
@inject IVocabularyConnector VocabularyConnector
@inject ISignalRRenameConnector SignalRRenameConnector

<PageTitle>Select folder</PageTitle>
<div class="mb-2">
    @_currentFolder
</div>
@if (_folderSelected && !_unknownEntries.Any())
{
    @if (_currentFolder != Root)
    {
        <div class="mb-2">
            <ButtonUp CurrentFolder="_currentFolder" ButtonUpClicked="() => OpenFolderAsync(GetParent())" />
        </div>
    }
    <div class="mb-2">
        <button class="btn-secondary" @onclick="SelectFoldersAgainAsync">Select another folder</button>
    </div>
}
@if (!_folderSelected)
{
    @if (_folders is null)
    {
        <div class="spinner-border" role="status">
            <span class="visually-hidden">Loading folders...</span>
        </div>
    }
    else if (_folders.Length == 0)
    {
        <p>No folders found.</p>
        <ButtonUp CurrentFolder="_currentFolder" ButtonUpClicked="() => OpenFolderAsync(GetParent())" />
    }
    else
    {
        <div class="modal show d-block" tabindex="-1">
            <div class="modal-dialog modal-lg">
                <div class="modal-content thick-border modal-back-color">
                    <div class="modal-header">
                        <h5 class="modal-title">Select folder</h5>
                    </div>
                    <div class="modal-body">
                        <ButtonUp CurrentFolder="_currentFolder" ButtonUpClicked="() => OpenFolderAsync(GetParent())" />
                        <ButtonCancel Clicked="CancelFolderSelection" />
                        <SelectFoldersGrid Items="CurrentFolders"
                                           OpenFolderClicked="s => OpenFolderAsync(s)"
                                           ReadUnknownWordsClicked="s => ReadUnknownWordsAsync(s)" />
                    </div>
                    @if (_currentlyReadFolder != string.Empty)
                    {
                        <div class="modal-footer">
                            <ReadingFolderProgress ProgressValue="@_progressValue"
                                                   ProgressMax="@_progressMax"
                                                   CurrentlyReadFolder="@_currentlyReadFolder" />
                        </div>
                    }
                </div>
            </div>
        </div>
    }
}
@if (_unknownEntries.Any())
{
    if (_unknownEntries.Any(x => !x.Value.IsCorrected()))
    {
        <UnknownWordsGrid NewEntries="_unknownEntries" SubmitClicked="SaveVocabulary" AllowEdit="false" />
    }
    else
    {
        <div class="mb-2">
            <button class="btn-success" @onclick="RenameItems" disabled="@_isRenaming">Rename items</button>
            <button class="btn-secondary" @onclick="DoFolderSelection">Select another folder</button>
        </div>
        @if (_isRenaming)
        {
            <RenamingProgress CurrentNumber="_changeValue"
                              MaxChanges="_changeMax"
                              FilesRenamed="_filesRenamed"
                              FoldersRenamed="_foldersRenamed" />
        }
    }
}

@code {
    private const string Root = "/";
    private int _changeMax = 1;
    private int _progressMax = 1;
    private int _changeValue = 0;
    private int _progressValue = 0;
    private bool _isRenaming = false;
    private string _currentFolder = Root;
    private FileItem[]? _folders = null!;
    private bool _folderSelected = false;
    private bool _foldersRenamed, _filesRenamed;
    private string _currentlyReadFolder = string.Empty;
    private CancellationTokenSource _cancellationTokenSource = new();
    private Dictionary<string, VocabularyEntry> _unknownEntries = new();


    [CascadingParameter] public IModalService? Modal { get; set; }

    protected override Task OnInitializedAsync()
        => OpenFolderAsync(_currentFolder);

    private IQueryable<FileItem> CurrentFolders
        => _folders?.AsQueryable() ?? new EnumerableQuery<FileItem>([]);

    private async Task OpenFolderAsync(string fullName)
    {
        if (FtpConnector != null)
        {
            var localCts = await RecreateCancellationTokenSource();
            var token = localCts.Token;

            _folders = await FtpConnector.ReadFoldersAsync(fullName, token);
            _currentFolder = fullName;
            StateHasChanged();
            if (!localCts.IsCancellationRequested)
                await CheckQuestionMarksAsync(localCts);
        }
    }

    private async Task CheckQuestionMarksAsync(CancellationTokenSource localCts)
    {
        var folders = _folders;
        var token = localCts.Token;
        if (folders != null && FtpConnector != null)
        {
            if (_cancellationTokenSource != localCts)
                return;

            _progressValue = 0;
            _progressMax = folders.Length;
            Console.WriteLine($"read {folders.Length} items");
            foreach (var fileItem in folders)
            {
                if (token.IsCancellationRequested || _cancellationTokenSource != localCts)
                {
                    if (_cancellationTokenSource == localCts)
                        SetReadingFinished();
                    return;
                }

                await CheckQuestionMarkAsync(fileItem, token);
                await Task.Yield();
            }
            if (_cancellationTokenSource == localCts)
                SetReadingFinished();
        }
    }

    private async Task CheckQuestionMarkAsync(FileItem fileItem, CancellationToken token)
    {
        _currentlyReadFolder = fileItem.Name;
        StateHasChanged();
        if (fileItem.FolderStatus == FolderStatus.Undefined)
        {
            await FtpConnector.CheckQuestionMarksAsync(fileItem, token);
            _progressValue++;
            if (fileItem.FolderStatus != FolderStatus.Undefined)
                StateHasChanged();
        }
    }

    private void SetReadingFinished()
    {
        _progressMax = 1;
        _progressValue = 0;
        _currentlyReadFolder = string.Empty;
        StateHasChanged();
    }

    private async Task ReadUnknownWordsAsync(string fullName)
    {
        _unknownEntries.Clear();
        var localCts = await RecreateCancellationTokenSource();
        var token = localCts.Token;
        SetReadingFinished();
        _currentFolder = fullName;
        _unknownEntries = await FtpConnector.ReadUnknownWordsAsync(fullName, token);
        _folderSelected = true;
        StateHasChanged();
    }

    private async Task SaveVocabulary()
    {
        await VocabularyConnector.UpsertEntriesAsync(_unknownEntries.Values);
    }

    private async Task RenameItems()
    {
        var localCts = await RecreateCancellationTokenSource();
        _isRenaming = true;
        var token = localCts.Token;
        var connectionId = await ConnectRenamingEventsAsync(token);
        var request = new RenameFileItemsRequest { Folder = _currentFolder, FileItemType = FileItemType.Folder, SignalRConnectionId = connectionId };
        var result = await FtpConnector.RenameItemsAsync(request, token);
        if (!result.Succeeded)
        {
            await CleanUpFailedRenameOperation(token, result);
            return;
        }
        _foldersRenamed = true;
        StateHasChanged();
        request.FileItemType = FileItemType.File;
        result = await FtpConnector.RenameItemsAsync(request, token);
        if (!result.Succeeded)
        {
            await CleanUpFailedRenameOperation(token, result);
            return;
        }
        _filesRenamed = true;
        StateHasChanged();
        await ShowRenamingSuccess();
        DoFolderSelection();
        SetCurrentFolderToOk();
        SetRenamingFinished();
    }

    private async Task ShowRenamingSuccess()
    {
        var parameters = new ModalParameters().Add("Message", $"Renamed {_changeValue} items in {_currentFolder}");
        var modal = Modal!.Show<MessageBox>("Succeeded", parameters);
        await modal.Result;
    }

    private async Task CleanUpFailedRenameOperation(CancellationToken token, RenameFileItemsResult result)
    {
        if (!token.IsCancellationRequested)
            await Js!.InvokeVoidAsync("alert", token, $"Could not rename {result.FailedFile}");
        SetRenamingFinished();
    }

    private async Task<string> ConnectRenamingEventsAsync(CancellationToken token)
    {
        var connectionId = await SignalRRenameConnector!.ConnectAsync(token);
        SignalRRenameConnector.CurrentItemCountChanged += SignalROnCurrentItemCountChanged;
        SignalRRenameConnector.CompleteItemCountChanged += SignalROnCompleteItemCountChanged;
        return connectionId;
    }

    private void SignalROnCurrentItemCountChanged(CurrentItemCount currentItemCount)
    {
        _changeValue = currentItemCount.Current;
        StateHasChanged();
    }

    private void SignalROnCompleteItemCountChanged(CompleteItemCount completeItemCount)
    {
        SetChangeMax(completeItemCount.Total);
        StateHasChanged();
    }

    private void SetRenamingFinished()
    {
        SignalRRenameConnector!.CurrentItemCountChanged -= SignalROnCurrentItemCountChanged;
        SignalRRenameConnector.CompleteItemCountChanged -= SignalROnCompleteItemCountChanged;
        SetChangeMax(1);
        _changeValue = 0;
        _isRenaming = false;
        _filesRenamed = false;
        _foldersRenamed = false;
        StateHasChanged();
    }

    private void SetChangeMax(int max)
    {
        _changeMax = max;
        if (_changeMax < 1)
            _changeMax = 1;
    }

    private async Task SelectFoldersAgainAsync()
    {
        _unknownEntries.Clear();
        _folderSelected = false;
        StateHasChanged();
        await OpenFolderAsync(_currentFolder);
    }

    private void SetCurrentFolderToOk()
    {
        var item = _folders?.FirstOrDefault(f => f.FullName == _currentFolder);
        if (item != null)
            item.FolderStatus = FolderStatus.Ok;
    }

    private string GetParent()
        => Path.GetDirectoryName(_currentFolder)?.Replace("\\", "/") ?? "/";

    public void Dispose()
    {
        _cancellationTokenSource.Cancel();
        _cancellationTokenSource.Dispose();
        SignalRRenameConnector?.DisposeAsync().AsTask().Wait();
    }

    private void DoFolderSelection()
    {
        _folderSelected = false;
        _unknownEntries.Clear();
    }

    private void CancelFolderSelection()
    {
        _folders = [];
        _cancellationTokenSource.Cancel();
    }

    private async Task<CancellationTokenSource> RecreateCancellationTokenSource()
    {
        var localCts = new CancellationTokenSource();
        await _cancellationTokenSource.CancelAsync();
        _cancellationTokenSource.Dispose();
        _cancellationTokenSource = localCts;
        return localCts;
    }

}